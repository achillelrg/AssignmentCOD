# Computational Design Assignment: Project Journey & Documentation

This document records the technical journey, challenges encountered, and logic applied during the completion of Part A, B, and C of the assignment.

## üõ†Ô∏è Part A: Foundation & XFOIL Interface
**Goal:** Automate XFOIL execution from Python.
**Challenges:**
-   **Subprocess Hanging:** XFOIL input via `stdin` was fragile. Using `communicate()` caused deadlocks when XFOIL waited for prompts that weren't expected.
-   **Result Parsing:** Initially relied on creating log files, which was slow and error-prone (file locking).
**Solution:**
-   Refactored `xfoil_runner.py` to use `subprocess.Popen` with direct `stdout` parsing.
-   Added timeout logic (10s) to kill XFOIL if it entered an infinite loop (e.g., stalled airfoil).

## üöÄ Part B: Optimization
**Goal:** Minimize Drag / Maximize Lift using Evolutionary Algorithms (GA/PSO).
**Methodology:**
-   Implemented a modular `AirfoilProblem` class to handle CST parameterization.
-   Used **Particle Swarm Optimization (PSO)** and **Genetic Algorithms (GA)**.
**Key Findings:**
-   **PSO** proved more robust for checking local refinement, finding a balanced design ($J \approx -3.8$).
-   **GA** with small populations (20/40) often got stuck or found exploiting geometries (e.g., self-intersections) before we added strict geometric checks.

## üß† Part C: Surrogate Modeling & Uncertainty
**Goal:** Reduce computational cost by training a Gaussian Process (Kriging) model.
**The Journey:**
1.  **Initial Attempt (Small Data):** Generated ~100 samples.
    -   *Result:* $R^2 < 0$. The model failed completely to predict Drag.
    -   *Reason:* 100 points in 6D space is too sparse to capture non-linear aerodynamic phenomena (Drag Buckets).
2.  **Logic Shift (Log-Space):**
    -   Recognized that Drag spans orders of magnitude ($0.01 \to 0.1$).
    -   Applied $y = \log_{10}(C_d)$ transformation. This improved stability but didn't solve the noise issue.
3.  **The "Hero Run" (Scale Up):**
    -   Launched a massive parallel generation (2000 samples, 8 cores).
    -   Generated 1171 valid samples.
    -   *Result:* $C_l$ prediction decent ($R^2 \approx 0.46$), but $C_d$ remained difficult.
4.  **Survivorship Bias Discovery:**
    -   The optimizer found a "Super Geometry" ($C_l=1.4$) that ultimately failed verification.
    -   **Diagnosis:** By filtering out failed runs during training, we created a model that verified "Aggressive = Good" but didn't know "Aggressive = Stall".
    -   **Lesson:** Robust ML for physics requires training on *failures* (with penalties) to define the feasible boundary.

## üìÇ Project Structure
-   `experiments/`: Runners for each part (`part_c_surrogate.py`, `part_c_opt_surrogate.py`).
-   `data/`: Organized by Part (A/B/C) -> Method -> Results.
-   `utils/`: Shared core logic (`xfoil_runner`, `cst`).
-   `optimizer/`: Custom implementations of GA/PSO.

---
*Generated by Antigravity Assistant*
